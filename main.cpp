//
//  main.cpp
//  opencvTest
//
//  Created by VicLee on 2017/8/5.
//  Copyright © 2017年 VicLee. All rights reserved.
//
#include <string>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <sstream>
#include <cstdio>
#include "time.h"  //for the timer

#include "Blob.h"


#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/video.hpp>

#include "opencv2/opencv.hpp"
#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui/highgui.hpp"

using namespace cv;
using namespace std;



const cv::Scalar SCALAR_BLACK = cv::Scalar(0.0, 0.0, 0.0);
const cv::Scalar SCALAR_PINK = cv::Scalar(255.0, 192.0, 203.0);
const cv::Scalar SCALAR_WHITE = cv::Scalar(255.0, 255.0, 255.0);
const cv::Scalar SCALAR_YELLOW = cv::Scalar(0.0, 255.0, 255.0);
const cv::Scalar SCALAR_GREEN = cv::Scalar(0.0, 200.0, 0.0);
const cv::Scalar SCALAR_RED = cv::Scalar(0.0, 0.0, 255.0);
const cv::Scalar SCALAR_BLUE = cv::Scalar(255.0, 0.0, 0);

void matchCurrentFrameBlobsToExistingBlobs(std::vector<Blob> &existingBlobs, std::vector<Blob> &currentFrameBlobs);
void addBlobToExistingBlobs(Blob &currentFrameBlob, std::vector<Blob> &existingBlobs, int &intIndex);
void addNewBlob(Blob &currentFrameBlob, std::vector<Blob> &existingBlobs);
double distanceBetweenPoints(cv::Point point1, cv::Point point2);
void drawAndShowContours(cv::Size imageSize, std::vector<std::vector<cv::Point> > contours, std::string strImageName);
void drawAndShowContours(cv::Size imageSize, std::vector<Blob> blobs, std::string strImageName);
void drawBlobInfoOnImage(std::vector<Blob> &blobs, cv::Mat &imgFrame2Copy);

bool checkIfBlobsCrossedTheLine(std::vector<Blob> &blobs, int &intHorizontalLinePosition, int &countup, int &countdown);
void drawCountupOnImage(int &countup, cv::Mat &imgFrame2Copy);
void drawCountdownOnImage(int &countdown, cv::Mat &imgFrame2Copy);


void calcCircles(const Mat &input, vector<Vec3f> &circles);
void drawCircle(Mat &input, const vector<Vec3f> &circles);




// Global variables
Mat imgFrame1; //current frame
Mat imgFrame2; //next frame
Mat imgFrame1Copy,imgFrame2Copy;
Mat imgThresh; //fg mask fg mask generated by MOG2 method
cv::Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
int num_threshold = 254;
int MAX = 255;


Mat img_background; //MOG2 background

int main(void) {
    
    cv::VideoCapture capVideo;
    
    cv::Mat imgFrame1;
    cv::Mat imgFrame2;
    
    std::vector<Blob> blobs;
    
    cv::Point crossingLine[2];
    namedWindow("imgFrame2Copy",CV_WINDOW_FULLSCREEN);
    
    int countup = 0;
    int countdown = 0;
    ///Users/viclee/Documents/opencv/peoplecounting/peoplecounting/demo2.mp4
    ///Users/viclee/Desktop/demovideo/a22.mpg

    //detectvideo
    capVideo.open("/Users/viclee/Documents/opencv/peoplecounting/peoplecounting/demo2.mp4");
    
    if (!capVideo.isOpened()) {                                                 // if unable to open video file
        std::cout << "error reading video file" << std::endl << std::endl;      // show error message
                return(0);                                                              // and exit program
    }
    else{
        cout<< "success"<<endl;
    }
    if (capVideo.get(CV_CAP_PROP_FRAME_COUNT) < 2) {
        std::cout << "error: video file must have at least two frames";
               return(0);
    }
    
    capVideo.read(imgFrame1);
    capVideo.read(imgFrame2);
    
    int intHorizontalLinePosition = (int)std::round((double)imgFrame1.rows * 0.5);
    
    crossingLine[0].x = 0;
    crossingLine[0].y = intHorizontalLinePosition;
    
    crossingLine[1].x = imgFrame1.cols - 1;
    crossingLine[1].y = intHorizontalLinePosition;
    
    char chCheckForEscKey = 0;
    
    bool blnFirstFrame = true;
    
    int frameCount = 2;
    pMOG2 = createBackgroundSubtractorMOG2(500, 32, false); //MOG2 approach, true with shadow, false without shadow
    
    //confirm camera or video is opened
    
    while(true){
        std::vector<Blob> currentFrameBlobs;

        //update the background model
        pMOG2->apply(imgFrame1, imgThresh);
        //pMOG2->getBackgroundImage(img_background);
        //cv::imshow("Background", img_background); //show background
        
        
        
        //do something to MOG2frame
        cv::Mat structuringElement3x3 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
        cv::Mat structuringElement5x5 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(5, 5));
        cv::Mat structuringElement7x7 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(7, 7));
        cv::Mat structuringElement15x15 = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(15, 15));
        
        

        cv::threshold(imgThresh, imgThresh, num_threshold, MAX, THRESH_BINARY); // from 0~MAX num>num_threshold set white, num<num_threshold set black
        //cv::imshow("threshold", fgMaskMOG2);
        
        for (unsigned int i = 0; i < 2; i++) {
            cv::erode(imgThresh, imgThresh, structuringElement5x5);
            cv::dilate(imgThresh, imgThresh, structuringElement5x5);
            cv::dilate(imgThresh, imgThresh, structuringElement5x5);
            
        }
        
        cv::Mat imgThreshCopy = imgThresh.clone();
        
        std::vector<std::vector<cv::Point> > contours;
        
        cv::findContours(imgThreshCopy, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);
        
        drawAndShowContours(imgThresh.size(), contours, "imgContours");
        
        std::vector<std::vector<cv::Point> > convexHulls(contours.size());
        
        for (unsigned int i = 0; i < contours.size(); i++) {
            cv::convexHull(contours[i], convexHulls[i],false);
        }
        
        drawAndShowContours(imgThresh.size(), convexHulls, "imgConvexHulls");
        
        for (auto &convexHull : convexHulls) {
            Blob possibleBlob(convexHull);
            
            if (possibleBlob.currentBoundingRect.area() > 400 &&
                possibleBlob.dblCurrentAspectRatio > 0.2 &&
                possibleBlob.dblCurrentAspectRatio < 4.0 &&
                possibleBlob.currentBoundingRect.width > 20 && //imgblock width
                possibleBlob.currentBoundingRect.height > 20 && //imgblock height
                possibleBlob.dblCurrentDiagonalSize > 60.0 &&
                (cv::contourArea(possibleBlob.currentContour) / (double)possibleBlob.currentBoundingRect.area()) > 0.50) {
                currentFrameBlobs.push_back(possibleBlob);
            }
        }
        
        //drawAndShowContours(imgThresh.size(), currentFrameBlobs, "imgCurrentFrameBlobs");
        
        
//        //////////
//        vector<Vec3f> circles;
//        imshow("123",imgThresh);
//        calcCircles(imgThresh, circles);
//        drawCircle(imgFrame1, circles);
//        
//        
//        imshow("Display window2", imgFrame1);
//        
//        //////////////////////

        if (blnFirstFrame == true) {
            for (auto &currentFrameBlob : currentFrameBlobs) {
                blobs.push_back(currentFrameBlob);
            }
        } else {
            matchCurrentFrameBlobsToExistingBlobs(blobs, currentFrameBlobs);
        }
        
        //drawAndShowContours(imgThresh.size(), blobs, "imgBlobs");
        
        imgFrame2Copy = imgFrame2.clone();          // get another copy of frame 2 since we changed the previous frame 2 copy in the processing above
        
        drawBlobInfoOnImage(blobs, imgFrame2Copy);
        
        bool blnAtLeastOneBlobCrossedTheLine = checkIfBlobsCrossedTheLine(blobs, intHorizontalLinePosition, countup, countdown);
        
        if (blnAtLeastOneBlobCrossedTheLine == true) {
            cv::line(imgFrame2Copy, crossingLine[0], crossingLine[1], SCALAR_GREEN, 2);
        }
        else {
            cv::line(imgFrame2Copy, crossingLine[0], crossingLine[1], SCALAR_RED, 2);
        }
        
        drawCountupOnImage(countup, imgFrame2Copy);
        drawCountdownOnImage(countdown, imgFrame2Copy);
        cv::imshow("imgFrame2Copy", imgFrame2Copy);
        
        //cv::waitKey(0);                 // uncomment this line to go frame by frame for debugging
        
        // now we prepare for the next iteration
        
        currentFrameBlobs.clear();
        
        imgFrame1 = imgFrame2.clone();           // move frame 1 up to where frame 2 is
        
        if ((capVideo.get(CV_CAP_PROP_POS_FRAMES) + 1) < capVideo.get(CV_CAP_PROP_FRAME_COUNT)) {
            capVideo.read(imgFrame2);
        }
        else {
            std::cout << "end of video\n";
            break;
        }
        
        blnFirstFrame = false;
        frameCount++;
        chCheckForEscKey = cv::waitKey(1);
    }

    
    if (chCheckForEscKey != 27) {               // if the user did not press esc (i.e. we reached the end of the video)
        cv::waitKey(0);                         // hold the windows open to allow the "end of video" message to show
    }
    // note that if the user did press esc, we don't need to hold the windows open, we can simply let the program end which will close the windows
    
    return(0);
}


void calcCircles(const Mat &input, vector<Vec3f> &circles){
    Mat contours;
    Canny(input,contours,50,150);
    HoughCircles(contours, circles, CV_HOUGH_GRADIENT, 1, 100, 200, 10,15,20);
}

void drawCircle(Mat &input, const vector<Vec3f> &circles){
    for(int i=0; i<circles.size(); i++){
        Point center(cvRound(circles[i][0]), cvRound(circles[i][1]));
        int radius = cvRound(circles[i][2]);
        circle(input, center, radius, SCALAR_BLUE, 3, 8, 0 );
    }
}



void matchCurrentFrameBlobsToExistingBlobs(std::vector<Blob> &existingBlobs, std::vector<Blob> &currentFrameBlobs) {
    
    for (auto &existingBlob : existingBlobs) {
        
        existingBlob.blnCurrentMatchFoundOrNewBlob = false;
        
        existingBlob.predictNextPosition();
    }
    
    for (auto &currentFrameBlob : currentFrameBlobs) {
        
        int intIndexOfLeastDistance = 0;
        double dblLeastDistance = 100000.0;
        
        for (unsigned int i = 0; i < existingBlobs.size(); i++) {
            
            if (existingBlobs[i].blnStillBeingTracked == true) {
                
                double dblDistance = distanceBetweenPoints(currentFrameBlob.centerPositions.back(), existingBlobs[i].predictedNextPosition);
                
                if (dblDistance < dblLeastDistance) {
                    dblLeastDistance = dblDistance;
                    intIndexOfLeastDistance = i;
                }
            }
        }
        
        if (dblLeastDistance < currentFrameBlob.dblCurrentDiagonalSize * 0.5) {
            addBlobToExistingBlobs(currentFrameBlob, existingBlobs, intIndexOfLeastDistance);
        }
        else {
            addNewBlob(currentFrameBlob, existingBlobs);
        }
        
    }
    
    for (auto &existingBlob : existingBlobs) {
        
        if (existingBlob.blnCurrentMatchFoundOrNewBlob == false) {
            existingBlob.intNumOfConsecutiveFramesWithoutAMatch++;
        }
        
        if (existingBlob.intNumOfConsecutiveFramesWithoutAMatch >= 5) {
            existingBlob.blnStillBeingTracked = false;
        }
        
    }
    
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void addBlobToExistingBlobs(Blob &currentFrameBlob, std::vector<Blob> &existingBlobs, int &intIndex) {
    
    existingBlobs[intIndex].currentContour = currentFrameBlob.currentContour;
    existingBlobs[intIndex].currentBoundingRect = currentFrameBlob.currentBoundingRect;
    
    existingBlobs[intIndex].centerPositions.push_back(currentFrameBlob.centerPositions.back());
    
    existingBlobs[intIndex].dblCurrentDiagonalSize = currentFrameBlob.dblCurrentDiagonalSize;
    existingBlobs[intIndex].dblCurrentAspectRatio = currentFrameBlob.dblCurrentAspectRatio;
    
    existingBlobs[intIndex].blnStillBeingTracked = true;
    existingBlobs[intIndex].blnCurrentMatchFoundOrNewBlob = true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void addNewBlob(Blob &currentFrameBlob, std::vector<Blob> &existingBlobs) {
    
    currentFrameBlob.blnCurrentMatchFoundOrNewBlob = true;
    
    existingBlobs.push_back(currentFrameBlob);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
double distanceBetweenPoints(cv::Point point1, cv::Point point2) {
    
    int intX = abs(point1.x - point2.x);
    int intY = abs(point1.y - point2.y);
    
    return(sqrt(pow(intX, 2) + pow(intY, 2)));
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void drawAndShowContours(cv::Size imageSize, std::vector<std::vector<cv::Point> > contours, std::string strImageName) {
    cv::Mat image(imageSize, CV_8UC3, SCALAR_BLACK);
    
    cv::drawContours(image, contours, -1, SCALAR_WHITE, -1);
    
    cv::imshow(strImageName, image);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void drawAndShowContours(cv::Size imageSize, std::vector<Blob> blobs, std::string strImageName) {
    
    cv::Mat image(imageSize, CV_8UC3, SCALAR_BLACK);
    
    std::vector<std::vector<cv::Point> > contours;
    
    for (auto &blob : blobs) {
        if (blob.blnStillBeingTracked == true) {
            contours.push_back(blob.currentContour);
        }
    }
    
    cv::drawContours(image, contours, -1, SCALAR_WHITE, -1);
    
    cv::imshow(strImageName, image);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
bool checkIfBlobsCrossedTheLine(std::vector<Blob> &blobs, int &intHorizontalLinePosition, int &countup, int &countdown) {
    bool blnAtLeastOneBlobCrossedTheLine = false;
    
    for (auto blob : blobs) {
        
        if (blob.blnStillBeingTracked == true && blob.centerPositions.size() >= 2) {
            int prevFrameIndex = (int)blob.centerPositions.size() - 2;
            int currFrameIndex = (int)blob.centerPositions.size() - 1;
            
            if (blob.centerPositions[prevFrameIndex].y > intHorizontalLinePosition && blob.centerPositions[currFrameIndex].y <= intHorizontalLinePosition) {
                countup++; //in
                blnAtLeastOneBlobCrossedTheLine = true;
            }
            else if (blob.centerPositions[prevFrameIndex].x < intHorizontalLinePosition && blob.centerPositions[currFrameIndex].x >= intHorizontalLinePosition) {
                countdown++; //out
                blnAtLeastOneBlobCrossedTheLine = true;
            }

        }
        
    }
    
    return blnAtLeastOneBlobCrossedTheLine;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void drawBlobInfoOnImage(std::vector<Blob> &blobs, cv::Mat &imgFrame2Copy) {
    
    for (unsigned int i = 0; i < blobs.size(); i++) {
        
        if (blobs[i].blnStillBeingTracked == true) {
            cv::rectangle(imgFrame2Copy, blobs[i].currentBoundingRect, SCALAR_RED, 2);
            
            int intFontFace = CV_FONT_HERSHEY_SIMPLEX;
            double dblFontScale = blobs[i].dblCurrentDiagonalSize / 60.0;
            int intFontThickness = (int)std::round(dblFontScale * 1.0);
            
            cv::putText(imgFrame2Copy, std::to_string(i), blobs[i].centerPositions.back(), intFontFace, dblFontScale, SCALAR_GREEN, intFontThickness);
        }
   }
}

///////////////////////////////////////////////////////////////////////////////////////////////////
void drawCountupOnImage(int &countup, cv::Mat &imgFrame2Copy) {
    
    int intFontFace = CV_FONT_HERSHEY_SIMPLEX;
    double dblFontScale = (imgFrame2Copy.rows * imgFrame2Copy.cols) / 300000.0;
    int intFontThickness = (int)std::round(dblFontScale * 1.5);
    
    cv::Size textSize = cv::getTextSize(std::to_string(countup), intFontFace, dblFontScale, intFontThickness, 0);
    
    cv::Point ptTextBottomLeftPosition;
    
    ptTextBottomLeftPosition.x = imgFrame2Copy.cols - 1 - (int)((double)textSize.width * 6);
    ptTextBottomLeftPosition.y = (int)((double)textSize.height * 1.25);
    
    cv::putText(imgFrame2Copy, "in : "+std::to_string(countup), ptTextBottomLeftPosition, intFontFace, dblFontScale, SCALAR_BLACK, intFontThickness);
    
}
void drawCountdownOnImage(int &countdown, cv::Mat &imgFrame2Copy) {
    
    int intFontFace = CV_FONT_HERSHEY_SIMPLEX;
    double dblFontScale = (imgFrame2Copy.rows * imgFrame2Copy.cols) / 300000.0;
    int intFontThickness = (int)std::round(dblFontScale * 1.5);
    
    cv::Size textSize = cv::getTextSize(std::to_string(countdown), intFontFace, dblFontScale, intFontThickness, 0);
    
    cv::Point ptTextBottomLeftPosition;
    
    ptTextBottomLeftPosition.x = imgFrame2Copy.cols - 1 - (int)((double)textSize.width * 7);
    ptTextBottomLeftPosition.y = (int)((double)textSize.height * 2.5);
    
    cv::putText(imgFrame2Copy, "out : "+std::to_string(countdown), ptTextBottomLeftPosition, intFontFace, dblFontScale, SCALAR_BLACK, intFontThickness);
    
}

